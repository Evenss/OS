实验提示：
	pipe()创建管道，用于有血缘关系之间的通信。（采用环形队列实现的）
	创建完管道完后，确定通信方向：父写子读，或子写父读。
	如果想创建多条管道，一定要先pipe()，再fork(),使子进程得以继承管道。

    使用管道时的四种注意情况：
    1） 写段关闭，读端读完管道里的内容时；再次读，返回0，相当于读到文件末尾EOF；
    2）写端未关闭，写端无数据， 读端读完管道里的数据时，再次读，阻塞。
    3）读端关闭，写段写管道，产生SIGPIPE信号，写进程默认情况下会终止进程。
    4）读端未读管道数据，当写段写满管道后，再次写，阻塞。
    Ps:使用管道，无须open，但需手动close。

    管道的缓冲区大小：1.函数的方法：fpathconf(int fd, int name);  第一个参数为管道描述符；第二个参数为情况标识符。
                        2.命令： ulimit -a;


1. 0--read 1--write
2. fork() 返回0表示子进程，返回>0的数字(子进程的pid号)表示父进程，返回<0表示fork失败
3. wait(0)一般是父进程用来等待子进程用的，用来防止子进程成为僵尸进程，0表示父进程不关心子进程的终止状态
4. int lockf(int fd, int cmd, off_t len);是库函数，而非系统调用，只支持排他锁
   cmd的取值为：
   F_LOCK(1)：给文件互斥加锁，若文件以被加锁，则会一直阻塞到锁被释放。
   F_TLOCK：同F_LOCK，但若文件已被加锁，不会阻塞，而回返回错误。
   F_ULOCK(0)：解锁。
   F_TEST：测试文件是否被上锁，若文件没被上锁则返回0，否则返回-1。
   len：为从文件当前位置的起始要锁住的长度。
